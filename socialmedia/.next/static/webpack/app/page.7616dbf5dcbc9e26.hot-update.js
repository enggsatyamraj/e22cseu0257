"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/services/authService.js":
/*!*************************************!*\
  !*** ./src/services/authService.js ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authenticatedRequest: () => (/* binding */ authenticatedRequest),\n/* harmony export */   getAuthToken: () => (/* binding */ getAuthToken),\n/* harmony export */   registerCompany: () => (/* binding */ registerCompany)\n/* harmony export */ });\n// src/services/authService.js\n/**\n * Service for handling authentication with the social media analytics API\n */ // API base URL\nconst API_BASE_URL = 'http://20.244.56.144/evaluation-service';\n// Fixed access token - for testing purposes\nconst FIXED_ACCESS_TOKEN = 'rtCHZJ';\n/**\n * Register company with the API server\n * @returns {Promise<Object>} Registration response with clientID and clientSecret\n */ const registerCompany = async (formData)=>{\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/register\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(formData || {\n                \"email\": \"ramkrishna@abc.edu\",\n                \"name\": \"Ram Krishna\",\n                \"mobileNo\": \"9999999999\",\n                \"githubUsername\": \"github\",\n                \"rollNo\": \"aa1bb\",\n                \"collegeName\": \"ABC University\",\n                \"accessCode\": \"rtCHZJ\"\n            })\n        });\n        const data = await response.json();\n        if (!response.ok) {\n            return {\n                success: false,\n                error: data.message || \"Registration failed: \".concat(response.status),\n                serverResponse: data\n            };\n        }\n        if (true) {\n            // Store credentials in localStorage for future use\n            localStorage.setItem('clientCredentials', JSON.stringify({\n                email: data.email,\n                name: data.name,\n                rollNo: data.rollNo,\n                accessCode: data.accessCode,\n                clientID: data.clientID,\n                clientSecret: data.clientSecret\n            }));\n        }\n        return {\n            success: true,\n            data\n        };\n    } catch (error) {\n        console.error('Registration error:', error);\n        return {\n            success: false,\n            error: error.message || 'Registration failed',\n            serverResponse: null\n        };\n    }\n};\n/**\n * Get authorization token from API\n * @returns {Promise<string>} Bearer token for API access\n */ const getAuthToken = async ()=>{\n    try {\n        if (false) {}\n        // Use the fixed access token for testing if available\n        if (FIXED_ACCESS_TOKEN) {\n            return FIXED_ACCESS_TOKEN;\n        }\n        // Check if token exists in localStorage and not expired\n        const storedToken = localStorage.getItem('authToken');\n        const tokenExpiry = localStorage.getItem('tokenExpiry');\n        if (storedToken && tokenExpiry && Number(tokenExpiry) > Date.now()) {\n            return storedToken;\n        }\n        // Get client credentials from localStorage\n        const credentialsStr = localStorage.getItem('clientCredentials');\n        if (!credentialsStr) {\n            throw new Error('No client credentials found. Please register first.');\n        }\n        const credentials = JSON.parse(credentialsStr);\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/auth\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                \"email\": credentials.email,\n                \"name\": credentials.name.toLowerCase(),\n                \"rollNo\": credentials.rollNo,\n                \"accessCode\": credentials.accessCode,\n                \"clientID\": credentials.clientID,\n                \"clientSecret\": credentials.clientSecret\n            })\n        });\n        const data = await response.json();\n        if (!response.ok) {\n            throw new Error(data.message || \"Auth token request failed: \".concat(response.status));\n        }\n        // Store token and expiry time\n        localStorage.setItem('authToken', data.access_token);\n        localStorage.setItem('tokenExpiry', data.expires_in * 1000 + Date.now());\n        return data.access_token;\n    } catch (error) {\n        console.error('Auth token error:', error);\n        throw error;\n    }\n};\n/**\n * Make authenticated API request\n * @param {string} endpoint - API endpoint to call\n * @param {Object} options - Fetch options\n * @returns {Promise<Object>} API response\n */ const authenticatedRequest = async function(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        const token = await getAuthToken();\n        if (!token) {\n            throw new Error('No authentication token available');\n        }\n        const response = await fetch(\"\".concat(API_BASE_URL).concat(endpoint), {\n            ...options,\n            headers: {\n                ...options.headers,\n                'Authorization': \"Bearer \".concat(token),\n                'Content-Type': 'application/json'\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"API request failed: \".concat(response.status));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error('API request error:', error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9hdXRoU2VydmljZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSw4QkFBOEI7QUFFOUI7O0NBRUMsR0FFRCxlQUFlO0FBQ2YsTUFBTUEsZUFBZTtBQUVyQiw0Q0FBNEM7QUFDNUMsTUFBTUMscUJBQXFCO0FBRTNCOzs7Q0FHQyxHQUNNLE1BQU1DLGtCQUFrQixPQUFPQztJQUNsQyxJQUFJO1FBQ0EsTUFBTUMsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWJMLGNBQWEsY0FBWTtZQUNyRE0sUUFBUTtZQUNSQyxTQUFTO2dCQUNMLGdCQUFnQjtZQUNwQjtZQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUNQLFlBQVk7Z0JBQzdCLFNBQVM7Z0JBQ1QsUUFBUTtnQkFDUixZQUFZO2dCQUNaLGtCQUFrQjtnQkFDbEIsVUFBVTtnQkFDVixlQUFlO2dCQUNmLGNBQWM7WUFDbEI7UUFDSjtRQUVBLE1BQU1RLE9BQU8sTUFBTVAsU0FBU1EsSUFBSTtRQUVoQyxJQUFJLENBQUNSLFNBQVNTLEVBQUUsRUFBRTtZQUNkLE9BQU87Z0JBQ0hDLFNBQVM7Z0JBQ1RDLE9BQU9KLEtBQUtLLE9BQU8sSUFBSSx3QkFBd0MsT0FBaEJaLFNBQVNhLE1BQU07Z0JBQzlEQyxnQkFBZ0JQO1lBQ3BCO1FBQ0o7UUFFQSxJQUFJLElBQTZCLEVBQUU7WUFDL0IsbURBQW1EO1lBQ25EUSxhQUFhQyxPQUFPLENBQUMscUJBQXFCWCxLQUFLQyxTQUFTLENBQUM7Z0JBQ3JEVyxPQUFPVixLQUFLVSxLQUFLO2dCQUNqQkMsTUFBTVgsS0FBS1csSUFBSTtnQkFDZkMsUUFBUVosS0FBS1ksTUFBTTtnQkFDbkJDLFlBQVliLEtBQUthLFVBQVU7Z0JBQzNCQyxVQUFVZCxLQUFLYyxRQUFRO2dCQUN2QkMsY0FBY2YsS0FBS2UsWUFBWTtZQUNuQztRQUNKO1FBRUEsT0FBTztZQUFFWixTQUFTO1lBQU1IO1FBQUs7SUFDakMsRUFBRSxPQUFPSSxPQUFPO1FBQ1pZLFFBQVFaLEtBQUssQ0FBQyx1QkFBdUJBO1FBQ3JDLE9BQU87WUFDSEQsU0FBUztZQUNUQyxPQUFPQSxNQUFNQyxPQUFPLElBQUk7WUFDeEJFLGdCQUFnQjtRQUNwQjtJQUNKO0FBQ0osRUFBRTtBQUVGOzs7Q0FHQyxHQUNNLE1BQU1VLGVBQWU7SUFDeEIsSUFBSTtRQUNBLElBQUksS0FBNkIsRUFBRSxFQUVsQztRQUVELHNEQUFzRDtRQUN0RCxJQUFJM0Isb0JBQW9CO1lBQ3BCLE9BQU9BO1FBQ1g7UUFFQSx3REFBd0Q7UUFDeEQsTUFBTTRCLGNBQWNWLGFBQWFXLE9BQU8sQ0FBQztRQUN6QyxNQUFNQyxjQUFjWixhQUFhVyxPQUFPLENBQUM7UUFFekMsSUFBSUQsZUFBZUUsZUFBZUMsT0FBT0QsZUFBZUUsS0FBS0MsR0FBRyxJQUFJO1lBQ2hFLE9BQU9MO1FBQ1g7UUFFQSwyQ0FBMkM7UUFDM0MsTUFBTU0saUJBQWlCaEIsYUFBYVcsT0FBTyxDQUFDO1FBRTVDLElBQUksQ0FBQ0ssZ0JBQWdCO1lBQ2pCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUVBLE1BQU1DLGNBQWM1QixLQUFLNkIsS0FBSyxDQUFDSDtRQUUvQixNQUFNL0IsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWJMLGNBQWEsVUFBUTtZQUNqRE0sUUFBUTtZQUNSQyxTQUFTO2dCQUNMLGdCQUFnQjtZQUNwQjtZQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7Z0JBQ2pCLFNBQVMyQixZQUFZaEIsS0FBSztnQkFDMUIsUUFBUWdCLFlBQVlmLElBQUksQ0FBQ2lCLFdBQVc7Z0JBQ3BDLFVBQVVGLFlBQVlkLE1BQU07Z0JBQzVCLGNBQWNjLFlBQVliLFVBQVU7Z0JBQ3BDLFlBQVlhLFlBQVlaLFFBQVE7Z0JBQ2hDLGdCQUFnQlksWUFBWVgsWUFBWTtZQUM1QztRQUNKO1FBRUEsTUFBTWYsT0FBTyxNQUFNUCxTQUFTUSxJQUFJO1FBRWhDLElBQUksQ0FBQ1IsU0FBU1MsRUFBRSxFQUFFO1lBQ2QsTUFBTSxJQUFJdUIsTUFBTXpCLEtBQUtLLE9BQU8sSUFBSSw4QkFBOEMsT0FBaEJaLFNBQVNhLE1BQU07UUFDakY7UUFFQSw4QkFBOEI7UUFDOUJFLGFBQWFDLE9BQU8sQ0FBQyxhQUFhVCxLQUFLNkIsWUFBWTtRQUNuRHJCLGFBQWFDLE9BQU8sQ0FBQyxlQUFlVCxLQUFLOEIsVUFBVSxHQUFHLE9BQU9SLEtBQUtDLEdBQUc7UUFFckUsT0FBT3ZCLEtBQUs2QixZQUFZO0lBQzVCLEVBQUUsT0FBT3pCLE9BQU87UUFDWlksUUFBUVosS0FBSyxDQUFDLHFCQUFxQkE7UUFDbkMsTUFBTUE7SUFDVjtBQUNKLEVBQUU7QUFFRjs7Ozs7Q0FLQyxHQUNNLE1BQU0yQix1QkFBdUIsZUFBT0M7UUFBVUMsMkVBQVUsQ0FBQztJQUM1RCxJQUFJO1FBQ0EsTUFBTUMsUUFBUSxNQUFNakI7UUFFcEIsSUFBSSxDQUFDaUIsT0FBTztZQUNSLE1BQU0sSUFBSVQsTUFBTTtRQUNwQjtRQUVBLE1BQU1oQyxXQUFXLE1BQU1DLE1BQU0sR0FBa0JzQyxPQUFmM0MsY0FBd0IsT0FBVDJDLFdBQVk7WUFDdkQsR0FBR0MsT0FBTztZQUNWckMsU0FBUztnQkFDTCxHQUFHcUMsUUFBUXJDLE9BQU87Z0JBQ2xCLGlCQUFpQixVQUFnQixPQUFOc0M7Z0JBQzNCLGdCQUFnQjtZQUNwQjtRQUNKO1FBRUEsSUFBSSxDQUFDekMsU0FBU1MsRUFBRSxFQUFFO1lBQ2QsTUFBTSxJQUFJdUIsTUFBTSx1QkFBdUMsT0FBaEJoQyxTQUFTYSxNQUFNO1FBQzFEO1FBRUEsT0FBTyxNQUFNYixTQUFTUSxJQUFJO0lBQzlCLEVBQUUsT0FBT0csT0FBTztRQUNaWSxRQUFRWixLQUFLLENBQUMsc0JBQXNCQTtRQUNwQyxNQUFNQTtJQUNWO0FBQ0osRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdHlhbXJhai9EZXNrdG9wL2Zyb250ZW5kL3NvY2lhbG1lZGlhL3NyYy9zZXJ2aWNlcy9hdXRoU2VydmljZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvc2VydmljZXMvYXV0aFNlcnZpY2UuanNcblxuLyoqXG4gKiBTZXJ2aWNlIGZvciBoYW5kbGluZyBhdXRoZW50aWNhdGlvbiB3aXRoIHRoZSBzb2NpYWwgbWVkaWEgYW5hbHl0aWNzIEFQSVxuICovXG5cbi8vIEFQSSBiYXNlIFVSTFxuY29uc3QgQVBJX0JBU0VfVVJMID0gJ2h0dHA6Ly8yMC4yNDQuNTYuMTQ0L2V2YWx1YXRpb24tc2VydmljZSc7XG5cbi8vIEZpeGVkIGFjY2VzcyB0b2tlbiAtIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG5jb25zdCBGSVhFRF9BQ0NFU1NfVE9LRU4gPSAncnRDSFpKJztcblxuLyoqXG4gKiBSZWdpc3RlciBjb21wYW55IHdpdGggdGhlIEFQSSBzZXJ2ZXJcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFJlZ2lzdHJhdGlvbiByZXNwb25zZSB3aXRoIGNsaWVudElEIGFuZCBjbGllbnRTZWNyZXRcbiAqL1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyQ29tcGFueSA9IGFzeW5jIChmb3JtRGF0YSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9yZWdpc3RlcmAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZm9ybURhdGEgfHwge1xuICAgICAgICAgICAgICAgIFwiZW1haWxcIjogXCJyYW1rcmlzaG5hQGFiYy5lZHVcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSYW0gS3Jpc2huYVwiLFxuICAgICAgICAgICAgICAgIFwibW9iaWxlTm9cIjogXCI5OTk5OTk5OTk5XCIsXG4gICAgICAgICAgICAgICAgXCJnaXRodWJVc2VybmFtZVwiOiBcImdpdGh1YlwiLFxuICAgICAgICAgICAgICAgIFwicm9sbE5vXCI6IFwiYWExYmJcIixcbiAgICAgICAgICAgICAgICBcImNvbGxlZ2VOYW1lXCI6IFwiQUJDIFVuaXZlcnNpdHlcIixcbiAgICAgICAgICAgICAgICBcImFjY2Vzc0NvZGVcIjogXCJydENIWkpcIlxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZGF0YS5tZXNzYWdlIHx8IGBSZWdpc3RyYXRpb24gZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c31gLFxuICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlOiBkYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBTdG9yZSBjcmVkZW50aWFscyBpbiBsb2NhbFN0b3JhZ2UgZm9yIGZ1dHVyZSB1c2VcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjbGllbnRDcmVkZW50aWFscycsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBlbWFpbDogZGF0YS5lbWFpbCxcbiAgICAgICAgICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgICAgICAgICAgcm9sbE5vOiBkYXRhLnJvbGxObyxcbiAgICAgICAgICAgICAgICBhY2Nlc3NDb2RlOiBkYXRhLmFjY2Vzc0NvZGUsXG4gICAgICAgICAgICAgICAgY2xpZW50SUQ6IGRhdGEuY2xpZW50SUQsXG4gICAgICAgICAgICAgICAgY2xpZW50U2VjcmV0OiBkYXRhLmNsaWVudFNlY3JldFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YSB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlZ2lzdHJhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdSZWdpc3RyYXRpb24gZmFpbGVkJyxcbiAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgYXV0aG9yaXphdGlvbiB0b2tlbiBmcm9tIEFQSVxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQmVhcmVyIHRva2VuIGZvciBBUEkgYWNjZXNzXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBdXRoVG9rZW4gPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gV2UncmUgcnVubmluZyBvbiB0aGUgc2VydmVyXG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2UgdGhlIGZpeGVkIGFjY2VzcyB0b2tlbiBmb3IgdGVzdGluZyBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKEZJWEVEX0FDQ0VTU19UT0tFTikge1xuICAgICAgICAgICAgcmV0dXJuIEZJWEVEX0FDQ0VTU19UT0tFTjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRva2VuIGV4aXN0cyBpbiBsb2NhbFN0b3JhZ2UgYW5kIG5vdCBleHBpcmVkXG4gICAgICAgIGNvbnN0IHN0b3JlZFRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhUb2tlbicpO1xuICAgICAgICBjb25zdCB0b2tlbkV4cGlyeSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbkV4cGlyeScpO1xuXG4gICAgICAgIGlmIChzdG9yZWRUb2tlbiAmJiB0b2tlbkV4cGlyeSAmJiBOdW1iZXIodG9rZW5FeHBpcnkpID4gRGF0ZS5ub3coKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JlZFRva2VuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGNsaWVudCBjcmVkZW50aWFscyBmcm9tIGxvY2FsU3RvcmFnZVxuICAgICAgICBjb25zdCBjcmVkZW50aWFsc1N0ciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjbGllbnRDcmVkZW50aWFscycpO1xuXG4gICAgICAgIGlmICghY3JlZGVudGlhbHNTdHIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY2xpZW50IGNyZWRlbnRpYWxzIGZvdW5kLiBQbGVhc2UgcmVnaXN0ZXIgZmlyc3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IEpTT04ucGFyc2UoY3JlZGVudGlhbHNTdHIpO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hdXRoYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgXCJlbWFpbFwiOiBjcmVkZW50aWFscy5lbWFpbCxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogY3JlZGVudGlhbHMubmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIFwicm9sbE5vXCI6IGNyZWRlbnRpYWxzLnJvbGxObyxcbiAgICAgICAgICAgICAgICBcImFjY2Vzc0NvZGVcIjogY3JlZGVudGlhbHMuYWNjZXNzQ29kZSxcbiAgICAgICAgICAgICAgICBcImNsaWVudElEXCI6IGNyZWRlbnRpYWxzLmNsaWVudElELFxuICAgICAgICAgICAgICAgIFwiY2xpZW50U2VjcmV0XCI6IGNyZWRlbnRpYWxzLmNsaWVudFNlY3JldFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEubWVzc2FnZSB8fCBgQXV0aCB0b2tlbiByZXF1ZXN0IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSB0b2tlbiBhbmQgZXhwaXJ5IHRpbWVcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhUb2tlbicsIGRhdGEuYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Rva2VuRXhwaXJ5JywgZGF0YS5leHBpcmVzX2luICogMTAwMCArIERhdGUubm93KCkpO1xuXG4gICAgICAgIHJldHVybiBkYXRhLmFjY2Vzc190b2tlbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdXRoIHRva2VuIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNYWtlIGF1dGhlbnRpY2F0ZWQgQVBJIHJlcXVlc3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCAtIEFQSSBlbmRwb2ludCB0byBjYWxsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEZldGNoIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEFQSSByZXNwb25zZVxuICovXG5leHBvcnQgY29uc3QgYXV0aGVudGljYXRlZFJlcXVlc3QgPSBhc3luYyAoZW5kcG9pbnQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ2V0QXV0aFRva2VuKCk7XG5cbiAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhdXRoZW50aWNhdGlvbiB0b2tlbiBhdmFpbGFibGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfSR7ZW5kcG9pbnR9YCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgcmVxdWVzdCBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBUEkgcmVxdWVzdCBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn07Il0sIm5hbWVzIjpbIkFQSV9CQVNFX1VSTCIsIkZJWEVEX0FDQ0VTU19UT0tFTiIsInJlZ2lzdGVyQ29tcGFueSIsImZvcm1EYXRhIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImRhdGEiLCJqc29uIiwib2siLCJzdWNjZXNzIiwiZXJyb3IiLCJtZXNzYWdlIiwic3RhdHVzIiwic2VydmVyUmVzcG9uc2UiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiZW1haWwiLCJuYW1lIiwicm9sbE5vIiwiYWNjZXNzQ29kZSIsImNsaWVudElEIiwiY2xpZW50U2VjcmV0IiwiY29uc29sZSIsImdldEF1dGhUb2tlbiIsInN0b3JlZFRva2VuIiwiZ2V0SXRlbSIsInRva2VuRXhwaXJ5IiwiTnVtYmVyIiwiRGF0ZSIsIm5vdyIsImNyZWRlbnRpYWxzU3RyIiwiRXJyb3IiLCJjcmVkZW50aWFscyIsInBhcnNlIiwidG9Mb3dlckNhc2UiLCJhY2Nlc3NfdG9rZW4iLCJleHBpcmVzX2luIiwiYXV0aGVudGljYXRlZFJlcXVlc3QiLCJlbmRwb2ludCIsIm9wdGlvbnMiLCJ0b2tlbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/authService.js\n"));

/***/ })

});